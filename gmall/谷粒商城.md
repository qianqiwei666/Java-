# 一、前置

## 一、分布式,微服务与集群的关系

> 1. 集群:将多台机器集中在一起,每台机器完成相同的事。每一台机器之间不一定要通讯。比如RocketMQ(nameserve),主要为了故障转移,以及高可用。
> 2. 分布式:多个服务部署到不同的机器上,每个服务做不同的事。每一个服务都可以搭集群。
> 3. 微服务:与分布式类似,都是多服务部署,只不过微服务可以部署到一台机器上。部署方式不一样而已。

## 二、负载均衡算法

### 一、为什么要用负载均衡算法

> 为了防止集群中的每一台机器不要太忙也不要太闲。

> 1. 轮询:从集群中依次进行选择调用,调用到最后一个服务的时候,从头开始。
> 2. 负载最低优先(最小连接):将任务优先分配到负载较低服务上。
> 3. 性能最优:将任务优先分配给性能较高的服务器上。
> 4. hash:主要为了保证用户能连接集群中相同的服务器。

## 三、服务雪崩

![请求积压](C:\Users\15915\Documents\笔记\谷粒商城项目\请求积压.png)

### 一、解决方案

> 1. 降级:设置超时时间,如果服务A调用服务B达到了阈值,对其进行降级。
> 2. 熔断:当降级次数达到了阈值,就进行熔断,设定熔断时间,过了熔断时间再对其进行调用,如果还调用失败,继续熔断。

## 四、docker搭建

> 一般容器中文件的数据一般存储在宿主机上。

> 在~目录创建卷映射文件 ~/docker-data/...

### 一、MySQL(8.0.29)

#### 一、路径详情:

> 1. docker中mysql的目录结构;
> 2. /var/lib/mysql:存放mysql的数据文件(包含binlog,db数据文件) 
> 3. /var/log/mysql;存放mysql的日志文件
> 4. /etc/mysql:存放的是mysql配置文件

##### 注意:

> mysql配置文件映射目录下创建MySQL配置文件(my.cnf)
>
> ```bash
> # Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
> #
> # This program is free software; you can redistribute it and/or modify
> # it under the terms of the GNU General Public License as published by
> # the Free Software Foundation; version 2 of the License.
> #
> # This program is distributed in the hope that it will be useful,
> # but WITHOUT ANY WARRANTY; without even the implied warranty of
> # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> # GNU General Public License for more details.
> #
> # You should have received a copy of the GNU General Public License
> # along with this program; if not, write to the Free Software
> # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
> 
> #
> # The MySQL  Server configuration file.
> #
> # For explanations see
> # http://dev.mysql.com/doc/mysql/en/server-system-variables.html
> 
> [mysqld]
> pid-file        = /var/run/mysqld/mysqld.pid
> socket          = /var/run/mysqld/mysqld.sock
> datadir         = /var/lib/mysql
> secure-file-priv= NULL
> 
> ```
>
> 

#### 二、启动Docker

```bash
docker run -p 4306:3306 --name qianqiwei-mysql  \
 -v /docker-data/mysql/mysql01/conf:/etc/mysql \
 -v /docker-data/mysql/mysql01/log:/var/log/mysql \
 -v /docker-data/mysql/mysql01/data:/var/lib/mysql \
 -e MYSQL_ROOT_PASSWORD=Qianqiwei2003817 \
 -itd registry.cn-hangzhou.aliyuncs.com/qianqiwei-images/mysql:1.0
```

### 二、redis(7.0.2)

#### 一、路径详情：

> 1. /etc/redis.conf:redis配置文件目录
> 2. /data:redis持久化文件

##### 注意:

> 1. 创建redis.conf文件,持久化文件映射到/data/目录下。
>
>    ```bash
>    dir /data/
>    appendonly yes
>    ```

#### 二、启动docker

```bash
docker run --name qianqiwei-redis -p 7379:6379 \
 -v /docker-data/redis/redis01/conf/redis.conf:/etc/redis.conf\
 -v /docker-data/redis/redis01/data/:/data\
 -itd registry.cn-hangzhou.aliyuncs.com/qianqiwei-images/redis:1.0 redis-server /etc/redis.conf
```

>  -itd redis:latest redis-server /etc/redis.conf 启动镜像后面可以跟命令。

### 三、ES(7.8.0)

#### 一、路径详情

> 1. es配置文件目录:/usr/share/elasticsearch/config
> 2. es数据存储目录:/usr/share/elasticsearch/data
> 3. es插件存储目录:/usr/share/elasticsearch/plugins
> 4. /docker-data/elasticsearch

#### 二、启动docker

```bash
#好像是启动网络,启动就是了
docker network create somenetwork 
```

```bash
#启动es
 docker run  --name qianqiwei-elasticsearch \
 -v /docker-data/elasticsearch/config/:/usr/share/elasticsearch/config/ \
 -v /docker-data/elasticsearch/data/:/usr/share/elasticsearch/data/  \
 -v /docker-data/elasticsearch/plugins/:/usr/share/elasticsearch/plugins/ \
 --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" \
 -itd registry.cn-hangzhou.aliyuncs.com/qianqiwei-images/elasticsearch:1.1
```

### 四、Seata(1.5.2)

#### 一、路径详情

> 1. /seata-server/resources:存放的是Seata配置文件。

#### 二、启动Docker

```bash
docker run --name seata-server \
        -p 8091:8091 \
        -p 7091:7091 \
        -v /docker-data/seata/conf:/seata-server/resources  \
        -e SEATA_IP=192.168.1.10 \ 
        -itd registry.cn-hangzhou.aliyuncs.com/qianqiwei-images/seata:1.0
```

### 五、nacos(2.1.0)

#### 一、路径详情

> 1. /home/nacos/conf:nacos配置文件

#### 二、启动docker

##### 一、单机部署

```bash
docker run --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849 \
  --env  MODE=standalone \
  --env SPRING_DATASOURCE_PLATFORM=mysql \
  --env MYSQL_SERVICE_HOST=192.168.1.8 \
  --env MYSQL_SERVICE_PORT=4306 \
  --env MYSQL_SERVICE_DB_NAME=nacos \
  --env MYSQL_SERVICE_USER=root \
  --env MYSQL_SERVICE_PASSWORD=Qianqiwei2003817 \
  --env MYSQL_DATABASE_NUM=1 \
  --env JVM_XMS=2G \
  --env JVM_XMX=2G \
  --env JVM_XMN=2G \
  -itd registry.cn-hangzhou.aliyuncs.com/qianqiwei-images/nacos:1.0
```

##### 二、集群部署

> 查看dockerhub官网。

### 六、minio部署

#### 一、路径详情

> 1. data:文件存储目录。

#### 二、docker部署

```bash
curl -sSL https://raw.githubusercontent.com/bitnami/bitnami-docker-minio/master/docker-compose.yml > docker-compose.yml
docker-compose up -d
```



```bash
docker run --name minio-server -p 9001:9001 -p 9000:9000 \
    --env MINIO_ROOT_USER="qianqiwei" \
    --env MINIO_ROOT_PASSWORD="Qianqiwei2003817" \
    --volume /docker-data/minio/data:/data \
    -itd registry.cn-hangzhou.aliyuncs.com/qianqiwei-images/minio:1.0
```

##### 注意:

> 可能mc更新,容器需要多次重启。

## 最后、部署的坑

> 1. 这里的127.0.0.1指的是容器里面的ip地址。千万别搞错了。
> 2. nacos2.1.x以后必须开放 9848跟9849不然你注册不了!!!

### 七、kibana 部署

#### 一、docker部署

```bash
#运行kibana 注意IP一定不要写错
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://6.0.2.52:9200 -p 5601:5601 -itd kibana:7.8.0
```

# 二、项目基本搭建

## 一、本次项目用到人人开源的部分组件

> 1. renren-fast:admin后台服务
> 2. renren-fast-vue:admin前台
> 3. renren-generator:admin增删改查生成器

# 三、经验

## 一、多级菜单查询

```java
 //第一步查询一级菜单
        return list().stream()
                .filter(item->item.getParentCid()==0)
                .map(item->{
                    //递归查询当前菜单是否有子菜单
                    item.setCategoryEntityList(getChildTree(item,list()));
                    return item;
                })
                //排序
                .sorted((item1,item2)->(item1.getSort()==null?0:item1.getSort())-(item2.getSort()==null?0:item2.getSort()))
                .collect(Collectors.toList());
```

```java
    //递归查询
    public List<CategoryEntity> getChildTree(CategoryEntity child,List<CategoryEntity> list){
                return list.stream()
                .filter(item->item.getParentCid()==child.getCatId())
                .map(item->{
                   item.setCategoryEntityList(getChildTree(item,list));
                   return item;
                 })
                .sorted((item1,item2)->(item1.getSort()==null?0:item1.getSort())-(item2.getSort()==null?0:item2.getSort()))
                .collect(Collectors.toList());
    }
```

## 二、MyBatis-plus逻辑删除

### 一、配置

```yml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1) 
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```

### 二、操作逻辑删除的字段

```java
@TableLogic
private Integer deleted;
```

## 三、阿里云文件存储

### 一、基本操作

> 基础操作查看阿里云oss SDK [连接](https://help.aliyun.com/document_detail/32009.html)

### 二、整合SpringBoot

> [阿里云oss SpringBootStater](https://github.com/alibaba/aliyun-spring-boot/tree/master/aliyun-spring-boot-samples/aliyun-oss-spring-boot-sample)

## 四、ES

### 一、搜索评分

> 索引命中越多,得分就越高(_score),搜索商品可以通过排名来展示商品数据。





# 四、数据校验

## 一、JSR303

> JSR303是一种规范准则。

### 二、校验

#### 一、controller

```java
 @PutMapping("/save")
  /**
  @Valid 加这个注解开始校验Bean
  BindingResult 会识别校验失败的Bean,供我们对其操作
  */
    public R save(@Valid @RequestBody BrandEntity brandEntity, BindingResult bindingResult){
        Map<String,String> errorMap=new HashMap<>();
        //是否校验错误
        if (bindingResult.hasErrors()){
            //获取校验错误的属性
            bindingResult.getAllErrors().forEach(item->{
                //获取到错误的消息
                String message=item.getDefaultMessage();
                //获取发生错误的字段
                String fieldName=item.getObjectName();
                errorMap.put(message,fieldName);
            });
            return R.error().put("data",errorMap);
        }
        //如果没有错误正确返回
        return R.ok();
    }
```

#### 二、Bean

> 属性上加注解,具体百度。

## 二、Spring集中处理校验异常

### 一、创建处理异常的controller

```java
/**
 * @author : 钱琪炜
 * @date : 2022/7/16
 */
//扫包处理哪个包下controller的异常
@RestControllerAdvice(basePackages = {"com.qianqiwei.gulimall_pms.controller"})
public class ExceptionHandlerController {

    //设置需要处理哪些异常
    @ExceptionHandler(value = {MethodArgumentNotValidException.class})
    //捕捉到异常
    public R CheckHandler(MethodArgumentNotValidException e){
        //这里可以获取到异常的信息,供自己处理
        BindingResult bindingResult = e.getBindingResult();
        Map<String,String> errorMap=new HashMap<>();
        if (bindingResult.hasErrors()){
            bindingResult.getAllErrors().forEach(item->{
                errorMap.put(item.getObjectName(),item.getDefaultMessage());
            });
        }
        return R.error().put("data",errorMap);
    }
    //剩下的其他异常都可以在这里自定义


    @ExceptionHandler(value = {Throwable.class})
    //处理未知的异常
    public R handlerUnknowException(Throwable throwable){
        return R.error().put("data","未知异常");
    }
}

```

## 三、校验分组

> 校验分组指的是在什么场合,进行什么校验

### 一、Bean属性演示

```java
  //当@
	@NotNull(message = "id不能为空",groups = {UpdateGroup.class})
	@Null(message = "id必须为空",groups = {AddGroup.class})
	@TableId
	private Long brandId;
```

### 二、controller展示

```java
    /**
     * 添加商品
     */
    @PutMapping("/save")
    /**
     @Validated  指定分组,交给指定分组的校验规则校验。
     BindingResult 会识别校验失败的Bean,供我们对其操作
     */
    public R save(@Validated(value = {AddGroup.class}) @RequestBody BrandEntity brandEntity, BindingResult bindingResult){
        Map<String,String> errorMap=new HashMap<>();
        //是否校验错误
        if (bindingResult.hasErrors()){
            //获取校验错误的属性
            bindingResult.getAllErrors().forEach(item->{
                //获取到错误的消息
                String message=item.getDefaultMessage();
                //获取发生错误的字段
                String fieldName=item.getObjectName();
                errorMap.put(message,fieldName);
            });
            return R.error().put("data",errorMap);
        }
        //如果没有错误正确返回
        return R.ok();
    }
```

## 四、错误码定义

> - ﻿错误码和错误信息定义类
> - ﻿1. 错误码定义规则为 5 为数字
> - ﻿2.前两位表示业务场景，最后三位表示错误码。例如：100001。 10-通用 001:系统末知
> - ﻿3.维护错误码后需要維护错误描述，将他们定义为枚举形式
> - ﻿错误码列表：
> - ﻿10: 通用
> - ﻿001：参数格式校验
> - ﻿11: 商品
> - ﻿12：订单
> - ﻿13•购物车
> - ﻿14．物流



## 五、性能优化

> 1. MySQL:查看MySQL是否存在索引失效
> 2. JVM:查看JVM是否频繁GC
> 3. 缓存:
>    1. 开启Mybatis一,二级缓存(不推荐,数据一致性问题)
>    2. 缓存到JVM内存中(不推荐,数据一致性问题)
>    3. 存放到redis中(推荐)
> 4. 日志:只保留错误日志

## 六、同步redis与数据库的数据

> 1. 双写模式:更改redis中的数据,同时更改数据库中的数据。缺点就是容易同步不及时产生脏数据。
> 2. 失效模式:删除redis中的数据,从新重MySQL中查询放到redis中。
> 3. 如果要保证数据的强一致性,上读写锁。
> 4. 经常修改的数据存放到redis中,经常读的数据存放到redis中。
> 5. canel完美解决方案。



## 七、视图解析最直接的方法

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("path").setViewName("viewName");
    }
}
```

## 八、跨域处理

```java
@Bean
public CorsWebFilter corsWebFilter(){
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();

    CorsConfiguration corsConfiguration = new CorsConfiguration();

    //1、配置跨域
    corsConfiguration.addAllowedHeader("*");
    corsConfiguration.addAllowedMethod("*");
    corsConfiguration.addAllowedOrigin("*");
    corsConfiguration.setAllowCredentials(true);

    source.registerCorsConfiguration("/**",corsConfiguration);
    return new CorsWebFilter(source);
}
```

## 九、短信验证码

###  一、配置

> 详情看官网
>
> 1. 手机号
> 2. 验证码
> 3. 公司签名
> 4. 模板id
> 5. appID
> 6. AccessKeyID
> 7. AccessKeySecret

### 二、验证码重复提交以及过期处理

> 将手机号与验证码存放到redis中并设置过期时间,请求验证码的时候判断redis中是否存在该手机号,如果存在返回错误状态码。



## 十、加密

### 一、MD5

```java
String code = DigestUtils.md5Hex("qianqiwei");
```

#### 一、优点

> 1. 固定长度
> 2. 防修改
> 3. 重复性小

#### 二、缺点

> 网站上已经有破解

### 二、解决方案

#### 一、加盐

```java
 //盐一样计算出的值也就一样
        String code = Md5Crypt.md5Crypt("qianqiwei".getBytes(StandardCharsets.UTF_8), "$1$code");
        System.out.println(code);
```

> 1.  将加密后的将数据以及盐存放到数据库中
> 2. 当校验密码的时候,只需要对密码进行加密,然后比对数据库中的密码(加密)即可。

## 十一、社交登陆

> 1. 登录成功查看用户是否以前登录过
> 2. 登录过:修改access_token,token过期时间,获取社交账号数据。
> 3. 没登录过:获取用户的信息,access_token,access_token过期时间,获取uid,获取社交账号数据

## 十二、session共享

![session执行流程](D:\Java笔记\Java-\gmall\session执行流程.svg)















# 一、SKU与SPU

## 一、SPU

> 指的是一个商品的基本参数(商品介绍以及商品特性。)

## 二、SKU

> 指的是真正能决定价格的参数。



# 五、遇到的坑

## 一、网关

> 网关只要做负载均衡必须在同一个namespace与同一个group否则调用不到!!!!!
