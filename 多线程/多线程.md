## 一、前置



#### 一 、线程启动的三种方式

```java
public class MyThread {
    //继承Thread类
    static class Thread1 extends Thread{
        @Override
        public void run() {
            System.out.println("我是:"+Thread.currentThread().getName());
        }
    }

    //实现Runnable接口
    static class Thread2 implements Runnable{
        @Override
        public void run() {
            System.out.println("我是:"+Thread.currentThread().getName());
        }
    }


    public static void main(String[] args) {
        //分别启动线程:
        new Thread1().start();

        new Thread(new Thread2()).start();
        
        new Thread(()->{
            System.out.println("我是:"+Thread.currentThread().getName());
        }).start();

    }


}
```

备注:

> 线程启动的三种方式: 
>
> 1. 继承Thread类
> 2. 实现Runnable接口
> 3. 通过线程池启动(Executors.newCachedThread)



#### 二、线程的三种方法

```java
Thread thread=new Thread(()->{
    for (int i=0;i<10;i++){
        try {
            //线程休眠
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+":"+i);
    }
},"线程一");

Thread thread2=new Thread(()->{
    for (int i=0;i<10;i++){
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (i==3){
            try {
                //线程join()
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(Thread.currentThread().getName()+":"+i);
    }
},"线程二");

thread.start();
thread2.start();
```



备注:

> 1. sleep: 线程休眠
> 2. yield: 使线程进入就绪状态
> 3. join: 线程加入



#### 三、线程的状态

```java
public static void main(String[] args) {
    //创建线程一
    Thread thread1 = new Thread(() -> {
        for (int i = 0; i < 10; i++) {
            try {
                //为了防止thread1比thread2先执行完成
                TimeUnit.MILLISECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });

    //创建线程二
    Thread thread2 = new Thread(() -> {
        for (int i = 0; i < 10; i++) {
            try {
                if (i==3){
                    //thread1运行中(RUNNABLE)
                    System.out.println(thread1.getState());
                    thread1.join();
                    //加入线程二直到线程一结束:(TERMINATED)
                    System.out.println(thread1.getState());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
    //观察thread1的状态
    //获取thread1初始状态(NEW)
    System.out.println(thread1.getState());
    thread1.start();
    thread2.start();
```



备注:

> 线程的运行流程: 
>
> ```mermaid
> flowchart LR
> NEW(NEW)--->RUNNABLE(RUNNABLE)--->TERMINATED(TERMINATED)
> ```
>
> 





#### 四、锁(synchronized)

1、售票案例

```java
//100张票
int ticket=100;
//上锁(synchronized(MyThread.class))
public synchronized void sales(){
    if (ticket>0){
        ticket--;
        System.out.println(Thread.currentThread().getName()+":"+ticket);
    }
}

public static void main(String[] args) {
    MyThread MyThread=new MyThread();
    new Thread(()->{
        while (MyThread.ticket>0){
            MyThread.sales();
        }
    },"线程一").start();

    new Thread(()->{
        while (MyThread.ticket>0){
            MyThread.sales();
        }
    },"线程二").start();
}
```

2、 在方法上加synchronized与静态方法上加synchronized的区别

2.1、非静态: 

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        //锁的可重入
        domain();
    }
    //这里的synchronized相当于synchronized(this),锁的是当前的对象    不是代码!!!
    public synchronized void domain(){

    }
}
```

2.2、静态: 

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        //锁的可重入
        domain();
    }
    //这里的synchronized相当于synchronized(MyThread.class),锁的MyThread这个对象
    public static synchronized void domain(){

    }
}
```

3、案例一: 

```java
public class MyThread {

    int i=100;
    public void show1() {
        while (i>0){
            //当执行完这个代码块的时候,锁就会得到释放
            synchronized (this){
               i--;
               System.out.println(Thread.currentThread().getName()+":"+i);
           }
       }
    }

    //这里没有加锁(不会等待其他锁执行完成而执行,单独执行)
    public void show(){
            System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread MyThread=new MyThread();
        new Thread(MyThread::show1).start();
        new Thread(MyThread::show1).start();
        new Thread(MyThread::show).start();

    }
}
```

备注:

> synchronized: 保证了原子性和可见性

#### 五、synchronized可重入 

1、案例:

```java
public class MyThread {

    //锁的可重入(都是同一个线程)
    public synchronized void show(){
        //Thread-0
        System.out.println("当前线程是:"+Thread.currentThread().getName());
        //调用synchronized方法
        domore();
    }

    //住:如果这里不加synchronized也是同一线程执行
    public synchronized void domore(){
        //Thread-0
        System.out.println("当前线程是:"+Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread MyThread=new MyThread();
        new Thread(MyThread::show).start();
    }

}
```

1.2 、继承也可以实现synchronized可重入:

```java
public class MyThread {

   static class A{
        public synchronized void show(){
            System.out.println(Thread.currentThread().getName());
        }
    }

    //这里锁的是父类的对象
   static class B extends A{
        public synchronized void show(){
            super.show();
            System.out.println(Thread.currentThread().getName());
        }
    }


    public static void main(String[] args) {
        A ab=new B();
        new Thread(ab::show).start();
    }

}
```

#### 六、线程与异常

```java
public class MyThread {    
    public synchronized void show() {
        //有锁进入
        System.out.println(Thread.currentThread().getState());
        System.out.println(Thread.currentThread().getName() + "遇到异常马上就要释放");
        //遇到异常直接释放锁(如果还有其他线程也会进入这个方法)
        int i=1/0;
    }

    public static void main(String[] args) {
        MyThread MyThread = new MyThread();
        new Thread(MyThread::show).start();
        new Thread(MyThread::show).start();


    }
}
```

备注:

> 异常释放锁(如果不想释放锁就catch住异常)



#### 七、小结

小结:

1、程序、进程、线程的区别

> 1. 程序: 指的是应用程序
> 2. 进程: 应用程序启动后产生的进程 
> 3. 线程: 进程的最小的执行单元(一个程序不同的执行路径叫线程)

2、坑:

>synchronized(this),不能锁基本数据类型包装类,以及String



## 二、Valatile与CAS操作



#### 一、synchronized的底层实现

1、synchronized历史: 

| synchronized早期 | 重量级(OS),导致效率低下。 |
| ---------------- | ------------------------- |
| 后来改进         | 有了锁升级概念            |

2、什么是锁升级:

​     2.1、偏向锁: 

```java
public class MyThread {
    Object object=new Object();
    public void test(){
        //1,第一次线程访问锁实际上没有给object加锁,只是记录当前线程的id,这叫偏向锁，下次访问还是同一个线程,直接执行,效率较高
        synchronized (object){

        }
    }
}
```

2.2、自旋锁: 

```java
public class MyThread {
    Object object=new Object();
    public void test(){
        //2,当第二个线程访问时候,如有其他线程正在占用,就会升级为自旋锁 自旋十次(消耗cpu资源)
        synchronized (object){

        }
    }
}
```

2.3、重量级锁:

```java
public class MyThread {
    Object object=new Object();
    public void test(){
        //3,自旋锁自旋十次之后就会升级为重量级锁,进入等待队列
        synchronized (object){

        }
    }
}
```

备注:

> 执行时间短线程数少用自选,执行时间长线程数多用重量级锁(OS)



#### 二、valatile概要

1.1、概念

> 1. 保证了线程的可见性
> 2. 禁止指令重排序
> 3. 不能保证原子性

```java
public class MyThread {
    volatile boolean running=true;
    public void change(){
        System.out.println("开始");
        while (running){
           
        }
        System.out.println("结束");
    }

    public static void main(String[] args) {
        MyThread MyThread=new MyThread();
        new Thread(MyThread::change).start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        MyThread.running=false;
    }
```

1.2、不能保证原子性

```java
volatile int i=0;
public void change(){
    while (i<100){
        i++;
        System.out.println(Thread.currentThread().getName()+":"+i);
    }
}
public static void main(String[] args) {
    MyThread MyThread=new MyThread();
    new Thread(MyThread::change).start();
    new Thread(MyThread::change).start();
}
```

备注:

> 1. volatile如果修饰的是一个引用,引用里所有的成员变量更方法都变得不可见。
> 2. volatile更不能修饰引用的属性。
> 3. volatile最好只修饰普通变量。

#### 三、synchronized优化

```java
public class MyThread {
    int i = 0;
    public void change() {
        while (i < 10000) {
            synchronized (this) {
                i++;
                if (i > 10000) return;
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
    public static void main(String[] args) throws IOException {
        MyThread myThread = new MyThread();
        new Thread(myThread::change).start();
        new Thread(myThread::change).start();
        new Thread(myThread::change).start();
    }
}
```

#### 四、CAS(自旋锁,无锁操作)

1.1、实现CAS操作的类:

> Atomic包下的类都是cas操作 (import java.util.concurrent.atomic.*)

1.2、CAS如何实现(AtomicInteger)

1.2.1、AtomicInteger类:

```java
//Unsafe类
private static final Unsafe unsafe = Unsafe.getUnsafe();
//保证value线程可见性
private volatile int value;

private static final long valueOffset;
//静态方法
static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

//初始化 AtomicInteger
public AtomicInteger(int initialValue) {
        value = initialValue;
}
//增加操作相当于i++;
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

//减少操作相当于i--;
public final int getAndDecrement() {
    return unsafe.getAndAddInt(this, valueOffset, -1);
}
//增加操作相当于--i;
 public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

 //减少操作相当于--i;
public final int decrementAndGet() {
      return unsafe.getAndAddInt(this, valueOffset, -1) - 1;
}
```

1.2.2、Usafe类:

```java
//操作
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        //native方法: public native int getIntVolatile(Object o, long offset);
        v = getIntVolatile(o, offset);
        //native方法: public final native boolean compareAndSwapInt(Object o, long offset,int                               expected,int x); 
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    //底层:if(offset==v){
    // v=v+delta;
    // return true;
    //}
    //return false;
    
    //CAS操作:1,compareAndSwapInt(Atomxxx对象, 需要修改的值, 期望修改的值, 新值)
    //       2,如果需要修改的值与期望值对应不上(被其他线程修改了),返回false重新在试,直到对应上,设置为新值。
    return v;
}

```

备注:

> CAS操作受cpu的原语支持(指令级别支持)，中间不能被打断的。

2.1、未能完成的实现:

2.1.1、手写Unsafe类(未能完成):

```java
public class MyUnsafe {
    private static MyUnsafe myUnsafe = null;

    //保证线程的安全
    public static MyUnsafe getMyUnsafe() {
        //锁的优化操作:
        if (myUnsafe == null) {
            synchronized (MyUnsafe.class) {
                if (myUnsafe == null) {
                    myUnsafe = new MyUnsafe();
                    return myUnsafe;
                }
            }
        }
        return myUnsafe;
    }

    public int getAndAddInt(int offset,int delta){
        int v;
        do {
            v=getIntVolatile(offset);
        }while (compareAndSwapInt(offset,v,v+delta));
        return v;
    }

    int offset=0;
    public int getIntVolatile(int offset){
        this.offset=offset;
        return this.offset;
    }

    public boolean compareAndSwapInt(int offset,int value,int delta){
        //如果传过来的值与期望值相等
        if (offset==value){
            this.offset=delta;
            return true;
        }
        return  false;
    }
    
}
```

2.1.2、手写AtomicInteger增加(未能实现):

```java
public class MyAtomicInteger {
    private MyUnsafe myUnsafe=MyUnsafe.getMyUnsafe();
    private Integer value;
    //初始化value
    public MyAtomicInteger(Integer initValue){
        value=initValue;
    }
    public MyAtomicInteger(){
        value=0;
    }
    //添加操作
    public Integer getAndIncrement(){
        return myUnsafe.getAndAddInt(value,1);
    }
    //查找元素
    public int get(){
        return value;
    }
}
```



## 三、锁



#### 一、LongAdder

1.1、Atomic与synchronized,LongAdder测试:

```java
public class MyThread {
    AtomicInteger atomicInteger=new AtomicInteger();
    public void AtomicTest(){
        for (int i=0;i<10000000;i++){
            atomicInteger.incrementAndGet();
        }
    }
    int x=0;
    public void SynchronizedTest(){
        for (int i=0;i<10000000;i++){
            synchronized (this){
                x+=1;
            }
        }
    }

    LongAdder longAdder=new LongAdder();
    public void LongAdderTest(){
        for (int i=0;i<10000000;i++){
            longAdder.increment();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread=new MyThread();
        long start = System.currentTimeMillis();
        Thread threads[]=new Thread[4];
        //分别创建4个线程
        for (int i=0;i<threads.length;i++){
            threads[i]=new Thread(myThread::AtomicTest);
        }
        //启动所有的线程
        for (Thread thread:threads) thread.start();
        //等待所有线程执行完成之后,然后执行主线程
        for (Thread thread:threads) thread.join();
        long end = System.currentTimeMillis();
        Long run_time=end-start;
        System.out.println(run_time+"毫秒");
    }
}
```

备注:

> 结论:
>
> 并发量小于10万级别:synchronized与Atomic,LongAdder运行速度差距很小。并发量一旦大于10万级别,synchronized与Atomic运行速度拉开差距。Atomic与LongAdder差距小。
>
> 并发量达到百万级:Atomic与LongAdder运行速度拉开差距:synchronized<Atomic<LongAdder
>
> 无锁并发是要比加锁效率要高(加锁后可能会申请重量级锁)

#### 二、ReentrantLock

1.1、实验:(lock,unlock,trylock)

```java
ReentrantLock reentrantLock=new ReentrantLock();
int num=0;
int i=0;
public void change(){
  while (num<10000){
      try {
         //上锁
         reentrantLock.lock();
         //执行操作
         num++;
         //对剩余的线程进行释放
         if (num>10000) return;
         System.out.println(Thread.currentThread().getName()+":"+num);
         i+=num;
     }catch (Exception e){
         e.printStackTrace();
     }finally {
         //执行结束释放锁
         reentrantLock.unlock();
     }
  }
}
public void change_other(){
    //尝试获得锁
    boolean hasLock=false;
    try {
        //两秒之内抢到锁,否则直接进行销毁。
        hasLock=reentrantLock.tryLock(2,TimeUnit.SECONDS);
        //抢到锁之后进行操作
        if (hasLock){
            System.out.println(Thread.currentThread().getName()+"抢到锁了,休息一秒钟....");
            TimeUnit.SECONDS.sleep(1);
        }
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        //抢到锁之后进行释放,否则啥也不干。
        if (hasLock){
            reentrantLock.unlock();
        }else{
            System.out.println(Thread.currentThread().getName()+":"+"我没有抢到锁");
        } 
    }

}
public static void main(String[] args) throws InterruptedException {
    MyThread myThread=new MyThread();
    Thread[] threads=new Thread[6];
    //创建四个线程去执行change方法,三个线程执行change_other方法
    for (int i=0;i<threads.length;i++){
        if (i>1){
            threads[i]=new Thread(myThread::change);
        }else{
            threads[i]=new Thread(myThread::change_other);
        }
    }
    //启动四个线程
    for (Thread thread:threads) thread.start();
    for (Thread thread:threads) thread.join();

}
```

```java
public class MyThread {
    ReentrantLock reentrantLock=new ReentrantLock(true);
    public void change(){
        boolean b=false;
        try {
             //只要线程等待(自旋)4秒后没有抢到锁,不做任何处理。
             b = reentrantLock.tryLock(4, TimeUnit.SECONDS);
             if (b){
                 System.out.println(Thread.currentThread().getName()+"抢到了锁");
                 TimeUnit.SECONDS.sleep(3);
             }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            if (b){
                reentrantLock.unlock();
            }
        }

    }
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread=new MyThread();
        Thread thread1=new Thread(myThread::change);
        Thread thread2=new Thread(myThread::change);
        Thread thread3=new Thread(myThread::change);
        Thread thread4=new Thread(myThread::change);
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
        thread1.join();
        thread2.join();
        thread3.join();
        thread4.join();
    }
}
```

1.2、ReentrantLock与synchronized对比:

```java
public class MyThread {
    ReentrantLock reentrantLock=new ReentrantLock();
    int x=0;
    public void reentrantLock_test(){
        for (int i=0;i<1000000;i++){
            try {
                reentrantLock.lock();
                x+=1;
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                reentrantLock.unlock();
            }
        }
    }
    public void synchronized_test(){
        for (int i=0;i<1000000;i++){
            synchronized (this){
                x+=1;
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread=new MyThread();
        Thread threads[]=new Thread[4];
        for (int i=0;i<threads.length;i++){
            threads[i]=new Thread(myThread::synchronized_test);
        }
        for (Thread thread:threads) thread.start();
        Long start=System.currentTimeMillis();
        for (Thread thread:threads) thread.join();
        Long end=System.currentTimeMillis();
        Long mill=end-start;
        System.out.println(mill+"毫秒");
        System.out.println(myThread.x);
    }
}
```

1.3、公平锁:

```java
public class MyThread {
    //设置fair=true为公平锁
    ReentrantLock reentrantLock=new ReentrantLock(true);
    public void change(){
        while (true){
            try {
                reentrantLock.lock();
                System.out.println(Thread.currentThread().getName());
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                reentrantLock.unlock();
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread=new MyThread();
        Thread thread1=new Thread(myThread::change);
        Thread thread2=new Thread(myThread::change);
        Thread thread3=new Thread(myThread::change);
        Thread thread4=new Thread(myThread::change);
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
        thread1.join();
        thread2.join();
        thread3.join();
        thread4.join();
    }
}
```

备注：

> 公平锁是让线程进入等待队列里，并非谁抢到锁就是谁的。

#### 三、CountDownlatch

1.1、代码:

```java
public class MyThread {
     CountDownLatch countDownLatch;
     public void change(){
             try {
                 //每秒执行一次
                 TimeUnit.SECONDS.sleep(1);
                 System.out.println(Thread.currentThread().getName());
                 //进行原子操作
                 countDownLatch.countDown();
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
     }
     public void doOperate(){
         //创建100个线程
         Thread threads[]=new Thread[100];
         //记录线程个数
         countDownLatch=new CountDownLatch(threads.length);
         for (int i=0;i<threads.length;i++){
             threads[i]=new Thread(()->change());
         }
         //启动所有的线程
         for (Thread thread:threads) thread.start();
         try {
             //等待countDownLatch为0(线程执行结束)
             //阻塞状态,当countDownLatch为0时放行。
             countDownLatch.await();
             System.out.println("所有的线程运行结束");
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
     }

    public static void main(String[] args) throws InterruptedException {
         MyThread myThread=new MyThread();
         myThread.doOperate();
    }
}
```

#### 四、CyclicBarrier

1.1、代码:

```java
public class MyThread {

    CyclicBarrier cyclicBarrier=new CyclicBarrier(20,()-> System.out.println("20个线程以满"));

    public void change(){
        try {
                System.out.println(Thread.currentThread().getName());
                //阻塞状态,当线程数量满20放行一次
                cyclicBarrier.await();
                System.out.println("我已经放行了");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread=new MyThread();
        Thread [] threads=new Thread[40];
        for (int i=0;i<threads.length;i++){
            threads[i]=new Thread(myThread::change);
        }

        for (Thread thread:threads){
            TimeUnit.SECONDS.sleep(1);
            thread.start();
        }
        for (Thread thread:threads) thread.join();
    }


}
```

备注:

> CountDownlatch与CyclicBarrier区别:
>
> 1. CountDownlatch线程执行完成,计数器达到0时,放行。(一次性)
> 2. CyclicBarrier当线程达到指定个数时,放行。(应用场景:限流)

#### 五、ReadWriteLock

1.1、概念

> 1. 读锁:共享锁
> 2. 写锁:排他锁

```java
public class MyThread {
    private ReentrantLock reentrantLock=new ReentrantLock();
    private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();
    private Lock readLock=readWriteLock.readLock();
    private Lock writeLock=readWriteLock.writeLock();

    private int value;

    public void read(Lock lock){
        try {
            lock.lock();
            System.out.printf("%s\n",Thread.currentThread().getName()+"读取数据:"+this.value);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            System.out.printf("%s\n","读取完成");
            lock.unlock();
        }
    }

    public void write(Lock lock,int value){
        try {
            lock.lock();
            System.out.printf("%s\n",Thread.currentThread().getName()+"写数据:");
            this.value=value;
            System.out.printf("%s\n","写入完成"+this.value);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void change(){
        Thread threads[]=new Thread[6];
        for (int i=0;i<threads.length;i++){
            if (i>3){
                threads[i]=new Thread(()->read(readLock));
            }else{
                threads[i]=new Thread(()->write(writeLock,new Random().nextInt(100)+1));
            }
        }
        for (Thread thread:threads) thread.start();

    }

    public static void main(String[] args) {
        new MyThread().change();
    }

}
```

备注:

> 写锁释放可能被读锁抢到,读的是临时数据。
>
> 读锁执行的时候可能被写锁抢到,重新读出新的数据。
>
> 当写锁执行完成之后,读出的才是最终数据。

#### 六、Semaphore

1.1、代码:

```java
  public class MyThread {
    //这里是指定有几个线程同时执行
    Semaphore semaphore = new Semaphore(3);
    

    public void change() {
            try {
                //限制指定线程个数进入。
                semaphore.acquire();
                System.out.printf("%s\n",Thread.currentThread().getName());
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                semaphore.release();
            }
        }
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        Thread threads[] = new Thread[100];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(myThread::change);
        }

        for (Thread thread : threads) thread.start();
        for (Thread thread : threads) thread.join();
    }


}
```

备注:

> 可以同时运行指定线程数量,多用于限流。

#### 七、Exchanger

1.1、代码:

```java
public class MyThread {
    Exchanger<String> exchanger=new Exchanger<>();

    public void change(){
        String name="张三";
        try {
            String exchange = exchanger.exchange(name);
            System.out.printf("%s\n",Thread.currentThread().getName()+":"+exchange);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void change1(){
        String name="李四";
        try {
            String exchange = exchanger.exchange(name);
            System.out.printf("%s\n",Thread.currentThread().getName()+":"+exchange);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void change2(){
        String name="王五";
        try {
            String exchange = exchanger.exchange(name);
            System.out.printf("%s\n",Thread.currentThread().getName()+":"+exchange);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void change3(){
        String name="赵六";
        try {
            String exchange = exchanger.exchange(name);
            System.out.printf("%s\n",Thread.currentThread().getName()+":"+exchange);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        MyThread myThread=new MyThread();
        new Thread(myThread::change,"线程1").start();
        new Thread(myThread::change1,"线程2").start();
        new Thread(myThread::change2,"线程3").start();
        new Thread(myThread::change3,"线程4").start();
    }

}
```

备注:

> 只能允许两个线程进行通讯。

#### 八、LockSupport

1.1、代码:

```java
public class MyThread {
    public void change(){
        for (int i=0;i<10;i++){
            synchronized (this){
                if (i==5){
                    //使线程进入阻塞状态,由于上了锁其他线程也会进入等待
                    LockSupport.park();
                }
                System.out.printf("%s\n",Thread.currentThread().getName()+":"+i);
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread=new MyThread();
        Thread thread1=new Thread(myThread::change,"线程一");
        Thread thread2=new Thread(myThread::change,"线程二");
        thread1.start();
        thread2.start();
        TimeUnit.SECONDS.sleep(1);
        //放行是线程进入非阻塞状态
        LockSupport.unpark(thread1);
        LockSupport.unpark(thread2);
    }
}
```

## 四、面试总结

#### 一、面试题(1)

> 淘宝:
>
> 实现一个容器,提供两个方法add,size,现在有两个线程, 线程1添加10个元素到容器里, 线程2实现监控元素的个数, 当元素个数到达5个时, 线程2给出提示并结束

```java
public class MyThread {

    //创建一个内部类
    class Demo {
        //用于线程之间同时检测sArrayList
        volatile ArrayList<String> arrayList = new ArrayList<>();

        //获取长度
        public int size() {
            return arrayList.size();
        }

        //添加元素
        public void add(String value) {
            arrayList.add(value);
        }
    }

    //创建内部类对象
    Demo demo = new Demo();
    //计数器,只要有一个线程结束了都要结束。
    CountDownLatch countDownLatch = new CountDownLatch(1);

    public void domore() {
        while (demo.size()<10) {
            try {
                //每秒添加一个元素
                //注意:如果不加就不会生效
                TimeUnit.SECONDS.sleep(1);
                demo.add("你好");
                System.out.println("添加元素");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void change() {
        System.out.printf("%s\n", "方法开始");
        while (demo.size() < 5) {

        }
        System.out.printf("%s\n", "数组的长度大于5");
        countDownLatch.countDown();
    }
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        //创建两个线程
        Thread thread1 = new Thread(myThread::domore);
        Thread thread2 = new Thread(myThread::change);
        thread1.start();
        thread2.start();
    }


}
```

备注:

> volatile最好不要修饰引用。
>
> 原因:volatile如果修饰的是引用数据类型,引用数据类型中的某方法某值发生了变化volatile是观察不到的。

1.1、不要用引用

```java
public class MyThread {

    //创建一个内部类
    class Demo {
        //用于线程之间同时检测int
        volatile int i=0;
        //获取大小
        public int size() {
            return i;
        }
        //添加元素
        public void add() {
            i++;
        }
    }

    //创建内部类对象
    Demo demo = new Demo();
    //计数器,只要有一个线程结束了都要结束。
    CountDownLatch countDownLatch = new CountDownLatch(1);

    public void domore() {
        while (demo.size()<10) {
                //每秒添加一个元素
                demo.add();
                System.out.println("添加元素");
        }
    }

    public void change() {
        System.out.printf("%s\n", "方法开始");
        while (demo.size() < 5) {

        }
        System.out.printf("%s\n", "int 大于5");
        countDownLatch.countDown();
    }
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        //创建两个线程
        Thread thread1 = new Thread(myThread::domore);
        Thread thread2 = new Thread(myThread::change);
        thread1.start();
        thread2.start();
    }


}
```

##### 解决方法

1、使用LockSupport:

```java
public class MyThread {
    //创建一个内部类
    static class Demo {
        //用于线程之间同时检测ArrayList
        ArrayList<String> arrayList = new ArrayList<>();

        //获取长度
        public int size() {
            return arrayList.size();
        }

        //添加元素
        public void add(String value) {
            arrayList.add(value);
        }
    }

    //lamboda表达式要求,必须这么写。
    static Thread thread1, thread2;

    public static void main(String[] args) {
        Demo demo = new Demo();
        thread1 = new Thread(() -> {
            //等待被唤醒
            LockSupport.park();
            System.out.println("容器容量大于5");
            LockSupport.unpark(thread2);
        });
        thread2 = new Thread(() -> {
            while (demo.size() < 10) {
                demo.add("你好");
                System.out.println(demo.size());
                //如果数组的长度等于5就唤醒线程1
                if (demo.size() == 5) {
                    LockSupport.unpark(thread1);
                    LockSupport.park();
                }
            }
        });
        thread1.start();
        thread2.start();

    }
}
```

2、使用notify,wait

```java
public class MyThread {
    //创建一个内部类
     static class Demo {
        //用于线程之间同时检测ArrayList
        ArrayList<String> arrayList = new ArrayList<>();
        //获取长度
        public int size() {
            return arrayList.size();
        }

        //添加元素
        public void add(String value) {
            arrayList.add(value);
        }
    }

    public static void main(String[] args) {
        Demo demo=new Demo();
        //加锁
        Object o=new Object();
        Thread thread1=new Thread(()->{
            synchronized (o){
                try {
                    //等待被其他线程唤醒
                    o.wait();
                    System.out.println("容器数量大于5");
                    //输出结果,唤醒其他线程,自己结束
                    o.notify();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread thread2=new Thread(()->{
            synchronized (o){
                while (demo.size()<10){
                    demo.add("你好");
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("添加");
                    if (demo.size()==5) {
                        //这里不能唤醒后不管,因为还没有释放锁
                        o.notify();
                        //唤醒之后等待,让出锁
                        try {
                            o.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }

        });
        thread1.start();
        thread2.start();

    }
}
```

备注:

> wait:等待并让出锁。
>
> notify:唤醒其他线程,自己不会释放锁。

3、使用CountDownLatch

```java
public class MyThread {
    //创建一个内部类
     static class Demo {
        //用于线程之间同时检测ArrayList
        ArrayList<String> arrayList = new ArrayList<>();
        //获取长度
        public int size() {
            return arrayList.size();
        }

        //添加元素
        public void add(String value) {
            arrayList.add(value);
        }
    }

    public static void main(String[] args) {
         Demo demo=new Demo();
         //创建CountDownLatch
         CountDownLatch countDownLatch=new CountDownLatch(1);
         new Thread(()->{
             while (demo.size()<10){
                 try {
                     TimeUnit.SECONDS.sleep(1);
                     demo.add("你好");
                     System.out.println("添加元素");
                     //如果容器的大小等于5 CountDownLatch减1,使另外一个线程运行。
                     if (demo.size()==5) countDownLatch.countDown();
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
             }

         },"线程一").start();


         new Thread(()->{
             try {
                 //等待CountDownLatch为0,放行。
                 countDownLatch.await();
                 System.out.println("容器大小为5");
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         },"线程二").start();
    }
}
```

#### 二、面试题(2)

1、使用synchronized

```java
public class MyThread {

    static  class Project<T>{
        //初始化集合
        volatile private LinkedList<T> collect=new LinkedList<>();
        //创建容器的最大值
        private int max_capacity=3;
        //设置计数器
        private int count;
        //创建锁
        private final Object object=new Object();

        //生产者
        public void put(T value){
            synchronized (object){
                //如果添加的数值大于容器的最大值,进行等待
                while (collect.size()==max_capacity){
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("添加值"+value);
                collect.add(value);
                count++;
                object.notifyAll();
            }
        }
        //消费者
        public T get(){
            synchronized (object){
                while (collect.size()==0){
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //删除数组的第一个值
                T t = collect.removeFirst();
                count--;
                object.notifyAll();
                return t;
            }
        }
    }

    public static void main(String[] args) {
        Project<String> project=new Project();
        //启动6个生产者线程
        //启动4个消费者线程
        Thread threads[]=new Thread[10];
        for (int i=0;i<threads.length;i++){
            if (i>3){
                threads[i]=new Thread(()->project.put(String.valueOf(Thread.currentThread().getName()+":"+new Random().nextInt(10)+1)));
            }else{
                threads[i]=new Thread(()-> System.out.println("取出值:"+project.get()));
            }
        }
        for (Thread thread:threads) thread.start();

    }
}
```

2、使用ReentrantLock

```java
public class MyThread {
    static class Project<T> {
        //初始化集合
        volatile private LinkedList<T> collect = new LinkedList<>();
        //创建容器的最大值
        private int max_capacity = 3;
        //创建锁
        private Lock lock = new ReentrantLock();
        //创建生产者
        private Condition provider = lock.newCondition();
        //创建消费者
        private Condition consumer = lock.newCondition();

        public void put(T value) {
            try {
                lock.lock();
                //如果集合的长度等于最大长度,让线程进入等待状态
                while (collect.size() == max_capacity) {
                    provider.await();
                }
                //添加元素
                collect.add(value);
                System.out.println("添加元素"+value);
                //唤醒消费者线程
                consumer.signalAll();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }

        public void get() {
            try {
                lock.lock();
                while (collect.size() == 0) {
                    consumer.await();
                }
                T t = collect.removeFirst();
                System.out.println("获取元素"+t);
                provider.signalAll();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }

    }

    public static void main(String[] args) {
        Project<String> project=new Project();
        //启动6个生产者线程
        //启动4个消费者线程
        Thread threads[]=new Thread[10];
        for (int i=0;i<threads.length;i++){
            if (i>3){
                threads[i]=new Thread(()->project.put(String.valueOf(Thread.currentThread().getName()+":"+new Random().nextInt(10)+1)));
            }else{
                threads[i]=new Thread(()-> project.get());
            }
        }
        for (Thread thread:threads) thread.start();

    }

}
```

备注:

> Condition:可以对指定的线程进行阻塞,唤醒。

#### 三、面试题(3)

题目:

> 要求用线程顺序打印A1B2C3......Z26

1、方式一(synchronized):

```java
public class MyThread {

    public static void main(String[] args) {
        Thread t1;
        Thread t2;
        char letters[] = new char[26];
        int subscript[] = new int[26];
        //初始化数据
        int i = 0;
        for (char x = 'A'; x <= 'Z'; x++) {
            letters[i] = x;
            i++;
        }
        for (int p=0;p<subscript.length;p++){
            subscript[p]=p+1;
        }
        final Object lock = new Object();
        t1 = new Thread(() -> {
            synchronized (lock) {
                for (int m = 0; m < 26; m++) {
                    System.out.print(letters[m] + "");
                    try {
                        lock.notify();
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        t2 = new Thread(() -> {
            synchronized (lock) {
                for (int m = 0; m < 26; m++) {
                    System.out.print(subscript[m] + "\t");
                    try {
                        lock.notify();
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        t1.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();

    }

}
```

1.1、优先级问题:

```java
public class MyThread {
    static boolean bool=true;
    public static void main(String[] args) {
        Thread t1;
        Thread t2;
        char letters[] = new char[26];
        int subscript[] = new int[26];
        //初始化数据
        int i = 0;
        for (char x = 'A'; x <= 'Z'; x++) {
            letters[i] = x;
            i++;
        }
        for (int p=0;p<subscript.length;p++){
            subscript[p]=p+1;
        }
        final Object lock = new Object();
        t1 = new Thread(() -> {
            synchronized (lock) {
                while (bool){
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                for (int m = 0; m < 26; m++) {
                    System.out.print(letters[m] + "\t");
                    try {
                        lock.notify();
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                lock.notify();
            }
        });

        t2 = new Thread(() -> {
            synchronized (lock) {
                bool=false;
                for (int m = 0; m < 26; m++) {
                    System.out.print(subscript[m]);
                    try {
                        lock.notify();
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                lock.notify();
            }
        });
        
        t1.start();
        t2.start();

    }

}
```

3、为什么Boolean不加volatile(实验)

```java
public class MyThread {
    static  boolean bool = true;

    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(() -> {
            System.out.println("开始");
            while (bool) {
                LockSupport.park();
            }
            System.out.println("结束");
        });
        thread.start();
        TimeUnit.SECONDS.sleep(2);
        bool=false;
        LockSupport.unpark(thread);

    }

}
```



2、方式二(ReentrantLock):

```java
public class MyThread {

    public static void main(String[] args) {
        Thread t1;
        Thread t2;
        char letters[] = new char[26];
        int subscript[] = new int[26];
        //初始化数据
        int i = 0;
        for (char x = 'A'; x <= 'Z'; x++) {
            letters[i] = x;
            i++;
        }
        for (int p = 0; p < subscript.length; p++) {
            subscript[p] = p + 1;
        }

        final ReentrantLock reentrantLock = new ReentrantLock();
        final Condition t1_lock=reentrantLock.newCondition();
        final Condition t2_lock=reentrantLock.newCondition();
        t1 = new Thread(() -> {
            try {
                reentrantLock.lock();
                for (int o=0;o<letters.length;o++){
                    System.out.print(letters[o]);
                    //唤醒t2线程
                    t2_lock.signal();
                    //t1线程让出锁,并且等待被唤醒
                    t1_lock.await();
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                reentrantLock.unlock();
            }
        });

        t2 = new Thread(() -> {
            try {
                reentrantLock.lock();
                for (int o=0;o<subscript.length;o++){
                    System.out.print(subscript[o]+"\t");
                    //同理
                    t1_lock.signal();
                    t2_lock.await();
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                reentrantLock.unlock();
            }
        });

        t1.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();

    }

}
```

3、方式三(LockSupport):

```java
public class MyThread {


    static Thread t1 = null;
    static Thread t2 = null;

    public static void main(String[] args) {
        char letters[] = new char[26];
        int subscript[] = new int[26];
        //初始化数据
        int i = 0;
        for (char x = 'A'; x <= 'Z'; x++) {
            letters[i] = x;
            i++;
        }
        for (int p = 0; p < subscript.length; p++) {
            subscript[p] = p + 1;
        }


        t1 = new Thread(() -> {
            for (int o = 0; o < letters.length; o++) {
                System.out.print(letters[o]);
                LockSupport.unpark(t2);
                LockSupport.park();
            }
        });

        t2 = new Thread(() -> {
            for (int o = 0; o < subscript.length; o++) {
                LockSupport.park();
                System.out.print(subscript[o] + "\t");
                LockSupport.unpark(t1);
            }
        });

        t1.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();

    }

}
```

4、方式四(BlockingQueue,SynchronousQueue,TransferQueue)

```java
public class MyThread {

    public static void main(String[] args) {
        Thread t1;
        Thread t2;
        char letters[] = new char[26];
        int subscript[] = new int[26];
        //初始化数据
        int i = 0;
        for (char x = 'A'; x <= 'Z'; x++) {
            letters[i] = x;
            i++;
        }
        for (int p = 0; p < subscript.length; p++) {
            subscript[p] = p + 1;
        }

        //还可以使用:
        //SynchronousQueue<Character> char_blockingQueue=new SynchronousQueue<>();
        //SynchronousQueue<Integer> int_blockingQueue = new SynchronousQueue<>();
      
        //TransferQueue<Character> char_blockingQueue=new LinkedTransferQueue<>();
        //TransferQueue<Integer> int_blockingQueue = new LinkedTransferQueue<>();
        
        
        BlockingQueue<Character> char_blockingQueue = new ArrayBlockingQueue<>(1);
        BlockingQueue<Integer> int_blockingQueue = new ArrayBlockingQueue<>(1);
        t1 = new Thread(() -> {
            for (int m = 0; m < 26; m++) {
                try {
                    char_blockingQueue.put(letters[m]);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t2 = new Thread(() -> {
            for (int m = 0; m < 26; m++) {
                try {
                    int_blockingQueue.put(subscript[m]);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t1.start();
        t2.start();
        while (true) {
            try {
                System.out.print(char_blockingQueue.take() + "" + int_blockingQueue.take() + "\t");
            } catch (Exception e) {

            }
        }

    }

}
```

5、方式五(Exchanger)有问题

```java
public class MyThread {
    public static void main(String[] args) {
        Thread t1;
        Thread t2;
        char letters[] = new char[26];
        int subscript[] = new int[26];
        //初始化数据
        int i = 0;
        for (char x = 'A'; x <= 'Z'; x++) {
            letters[i] = x;
            i++;
        }
        for (int p = 0; p < subscript.length; p++) {
            subscript[p] = p + 1;
        }

        Exchanger exchanger=new Exchanger();

        t1 = new Thread(() -> {
            for (int m = 0; m < 26; m++) {
                try {
                    System.out.print(letters[m]);
                    exchanger.exchange("t1");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t2 = new Thread(() -> {
            for (int m = 0; m < 26; m++) {
                try {
                    exchanger.exchange("t2");
                    System.out.print(subscript[m]);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t1.start();
        t2.start();


    }

}
```

## 五、引用

#### 一、前置

1、java有哪些引用?

> 1. 强引用
> 2. 软引用
> 3. 弱引用
> 4. 虚引用

#### 二、ThreadLocal

1、 代码:

```java
public class MyThread {
    public static void main(String[] args) {
        ThreadLocal<User> threadLocal=new ThreadLocal<>();
        new Thread(()->{
            //获取对象(报错,没有在当前线程设置值)
            User user = threadLocal.get();
            user.setUsername("Nihao");
        }).start();

        new Thread(()->{
            //在当前线程set一个对象
            threadLocal.set(new User());
            //获取当前线程对象
            User user = threadLocal.get();
            System.out.println(user.getUsername());
        }).start();
    }

}
```

备注:

> ThreadLocal可以保证线程之间都有自己的作用域，互不干扰。



#### 三、强引用

1.1、什么是强引用?

> java里创建一个对象,例如:
>
> ```java
> Object obj=new Object();
> ```
>
> 

1.2、什么是垃圾回收

> 在Java中废弃的对象,Java垃圾回收器会自动回收此对象,调用finalize方法

```java
public class MyThread {
    @Override
    protected void finalize() throws Throwable {
        System.out.println("我被回收了");
    }
    public static void main(String[] args) throws IOException {
        MyThread myThread=new MyThread();
        //将引用指向别人。(回收此对象)
        myThread=null;
        //调用垃圾回收器(回收调用之前的对象)。
        System.gc();
        //阻塞当前线程。
        System.in.read();
    }

}
```

#### 四、软引用

1、软引用特点:

> 一个对象只有软引用引用他,当系统内存(堆内存)不够时,就会被垃圾回收器回收掉。

```java
public class MyThread {
    //已经设置堆的固定大小为20m
    public static void main(String[] args) throws IOException, InterruptedException {
        //创建软引用在堆的大小。
        SoftReference<byte[]> softReference=new SoftReference(new byte[1024*1024*10]);
        //获取软引用里的对象。
        System.out.println(softReference.get());
        //启动gc
        System.gc();
        //主线程睡眠5毫秒
        Thread.sleep(500);
        try {
            //设置强引用在堆的大小。
            byte bytes[]=new byte[1024*1024*15];
        }catch (Exception e){
            System.out.println("内存爆满");
        }finally {
            //当堆的大小超过最大容量,直接回收软引用。
            System.out.println(softReference.get());
        }

    }

}
```

备注:

> 软引用一般作为缓存用。

#### 五、弱引用

1、什么是弱引用(概念):

> 只要垃圾回收器看见弱引用,直接回收。

```java
public class MyThread {
    public static void main(String[] args) {
        //创建一个弱引用
        WeakReference<User> weakReference=new WeakReference<>(new User());
        //获取对象
        System.out.println(weakReference.get());
        //垃圾回收器回收弱引用
        System.gc();
        //对象已经被回收了
        System.out.println(weakReference.get());
    }

}
```

#### 六、虚引用

1、堆内存不足gc掉:

```java
public class MyThread {
    //虚拟机已经分配20m容量
    //创建引用队列
    private ReferenceQueue<User> referenceQueue = new ReferenceQueue<>();
    public void change() throws InterruptedException {
        //创建虚引用(类似与软引用)
        PhantomReference<User> phantomReference = new PhantomReference<>(new User(), referenceQueue);
        phantomReference.get();
        try {
            //往堆内存存入20m,让堆内存溢出,用来回收虚引用
            byte b[] = new byte[1024 * 1024 * 20];
        } catch (OutOfMemoryError e) {
            System.out.println("内存溢出");
        } finally {
            TimeUnit.SECONDS.sleep(1);
            System.out.println(referenceQueue.poll());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        myThread.change();
    }
}
```

2、遇见gc回收

```java
public class MyThread {
    //虚拟机已经分配20m容量
    //创建引用队列
    private ReferenceQueue<User> referenceQueue = new ReferenceQueue<>();

    public void change() throws InterruptedException {
        //创建虚引用
        //当遇到gc时将会被回收(类似于弱引用)
        PhantomReference<User> reference = new PhantomReference<>(new User(), referenceQueue);
       //User user1 = reference.get();
       //gc回收
         System.gc();
      //User user2 = reference.get();
        TimeUnit.SECONDS.sleep(1);
        //回收后进入引用队列的结果
        System.out.println(referenceQueue.poll());
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        myThread.change();
    }


}
```

备注:

> 虚引用：当内存不够时(或者是被gc看到了),就会回收对象到引用队列里。

## 六、容器

#### 一、前置

1、概念

> Java中collection接口包含List,Set,Queue,其中Queue为高并发做准备的。

#### 二、ConcurrentHashMap的发展

1.1、缺陷：

> 早期设计Vector跟HashTable自带锁,从而效率比较低下（现在synchronized效率比较高）,现在基本不用。

1.2、优点:

> 能保证线程安全，能保证原子。

1.3、改进:

> 新增HashMap,但是HashMap不能保证原子操作,于是新增了Collections类:  Collections.synchronizedList()方法,对容器进行原子操作。

2、代码示例(线程不安全):

```java
public class MyThread {
    public static void main(String[] args) throws InterruptedException {
        //创建ArrayList(线程不安全)
        ArrayList<Integer> arrayList = new ArrayList<>();
        //创建线程安全的List
        List<Integer> integers = Collections.synchronizedList(arrayList);
        //开启不同的线程对list进行操作
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 500; i++) {
                integers.add(i);
            }
        });
        Thread thread2 = new Thread(() -> {
            for (int i = 500; i < 1000; i++) {
                integers.add(i);
            }
        });
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        int m = 0;
        for (int i : integers) {
            m += i;
        }
        System.out.println(m);
    }
}
```

3、HashMap(加锁),HashTable,concurrentHashMap测试:

```java
public class MyThread {
    //创建初始化值
    static class Contains {
        //创建线程个数
        static public int thread_count = 1000;
        //创建key,value个数
        static public int uuid_count = 100000000;
    }

    //创建集合
    private static Map<UUID, UUID> hashtable;
    //创建key
    private static UUID keys[] = new UUID[Contains.uuid_count];
    //创建value
    private static UUID values[] = new UUID[Contains.uuid_count];
    //检测写线程执行状况
    private static CountDownLatch write_countDownLatch = new CountDownLatch(Contains.thread_count);
    //检测读线程运行状况
    private static CountDownLatch read_countDownLatch = new CountDownLatch(Contains.thread_count);

    //初始化数值
    public MyThread(Map<UUID, UUID> map) {
        //初始化map
        hashtable = map;
        for (int i = 0; i < Contains.uuid_count; i++) {
            keys[i] = UUID.randomUUID();
            values[i] = UUID.randomUUID();
        }
    }

    //写入部分
    private static class ThreadIncr implements Runnable {
        //创建每个线程遍历uuid的最小值
        int start;
        //创建线程执行最大个数
        int grap = Contains.uuid_count / Contains.thread_count;

        public ThreadIncr(int count) {
            start = count;
        }

        @Override
        public void run() {
            //分段添加数据
            for (int i = start; i < (start + grap); i++) {
                hashtable.put(keys[i], values[i]);
            }
            write_countDownLatch.countDown();
        }
    }

    //获取获取个数
    //private static AtomicInteger integer=new AtomicInteger();
    //读取部分
    private static class ThreadDecr implements Runnable {
        //创建每个线程遍历uuid的最大值
        int start;
        //创建线程执行最小个数
        int grap = Contains.uuid_count / Contains.thread_count;

        public ThreadDecr(int count) {
            start = count;
        }

        @Override
        public void run() {
            //分段添加数据
            for (int i = start - 1; i >= (start - grap); i--) {
           //integer.incrementAndGet();
                hashtable.get(keys[i]);
            }
            read_countDownLatch.countDown();
        }
    }


    //向hashTable写入数据
    public Long write() {
        //创建指定的线程数量
        Thread threads[] = new Thread[Contains.thread_count];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(new ThreadIncr(i * (Contains.uuid_count / Contains.thread_count)));
        }
        long start = System.currentTimeMillis();
        for (Thread thread : threads) thread.start();
        try {
            write_countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //检测装载数量是否正确
        int size = hashtable.size();
        long end = System.currentTimeMillis();
        //判断集合数量是否正确
        if (size == 1000000) {
            return (end - start);
        }
        return null;
    }

    //向hashTable读取数据
    public Long read() {
        Thread threads[] = new Thread[Contains.thread_count];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(new ThreadDecr((Contains.thread_count - i) * (Contains.uuid_count / Contains.thread_count)));
        }
        long start = System.currentTimeMillis();
        for (Thread thread : threads) thread.start();
        try {
            read_countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //检测装载数量是否正确
        int size = hashtable.size();
        long end = System.currentTimeMillis();
        //判断集合数量是否正确
        if (size == 1000000) {
       //System.out.println("获取个数:"+integer);
            return (end - start);
        }

        return null;
    }
    
    public static void main(String[] args) {
        ConcurrentHashMap<UUID,UUID> concurrentHashMap=new ConcurrentHashMap<>();
        MyThread myThread = new MyThread(concurrentHashMap);
        System.out.println(myThread.write());
        System.out.println(myThread.read());
    }

}
```

备注:

> concurrentHashMap在写方面比不过HashMap(加锁),HashTable,但是在读方面比两者效率都要高。

#### 三、Vector到Queue的发展

1.1、测试List(保证线程安全)

```java
public class MyThread {

    //创建容器
    private List<Integer> list;

    //初始化容器
    public MyThread(List<Integer> list) {
        this.list = list;
        for (int i = 0; i < 10000; i++) {
            list.add(i);
        }
    }

    //获取容器
    public List<Integer> getList() {
        return list;
    }


    public static void main(String[] args) {
        MyThread myThread = new MyThread(new ArrayList<>());
        List<Integer> list = myThread.getList();
        Thread[] threads = new Thread[10];
        //模拟100个人同时抢第一张票
        int x = 0;
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                while (list.size() > 0) {
                    synchronized (MyThread.class) {
                        if (list.size()<=0) break;
                        System.out.println("销售了:" + list.remove(0));
                    }
                }
            });
        }
        for (Thread thread : threads) thread.start();


    }

}
```

1.2、Deque(线程安全)

```java
public class MyThread {
   ConcurrentLinkedDeque<Integer> concurrentLinkedDeque=new ConcurrentLinkedDeque();
    //初始化容器
    public MyThread() {
        for (int i = 0; i < 10000; i++) {
            concurrentLinkedDeque.add(i);
        }
    }
    //获取容器
    public ConcurrentLinkedDeque<Integer> getConcurrentLinkedDeque() {
        return concurrentLinkedDeque;
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        ConcurrentLinkedDeque<Integer> linkedDeque = myThread.getConcurrentLinkedDeque();
        Thread[] threads = new Thread[10];
        //模拟100个人同时抢第一张票
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                while (true){
                    //poll()是原子性的
                    Integer poll = linkedDeque.poll();
                    if (poll==null) return;
                }
            });
        }

        for (Thread thread : threads) thread.start();
    }

}
```

备注:

> ConcurrentLinkedDeque在多线程中效率高。

#### 四、CopyOnWriteArrayList

概念:

> 适合读比较多,写比较少的情况。类似于ReadWriteLock

```java
public class MyThread {

    //特性:每添加一次都会比上一个数组的长度长。
    CopyOnWriteArrayList<String> list=new CopyOnWriteArrayList<>();
    //模拟写
    public Long write(){
        Thread threads[]=new Thread[100];
        CountDownLatch countDownLatch=new CountDownLatch(threads.length);
        for (int i=0;i<threads.length;i++){
            threads[i]=new Thread(()->{
                for (int x = 0; x <10; x++){
                    //add()底层用了ReentrantLock,保证了线程安全。
                    list.add(Thread.currentThread().getName()+":"+new Random().nextInt(10)+1);
                }
                countDownLatch.countDown();
            });
        }
        long start = System.currentTimeMillis();
        for (Thread thread:threads) thread.start();
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long end = System.currentTimeMillis();
        return (end-start);
    }
    //模拟读
    public void read(){
        Thread threads[]=new Thread[100];
        for (int i=0;i<threads.length;i++){
            threads[i]=new Thread(()->{
                while (true){
                    //get()底层没有上锁,读取效率更高
                    System.out.println(list.get(new Random().nextInt(1000)));
                }
            });
        }
        for (Thread thread:threads) thread.start();
    }

    public static void main(String[] args) {
        MyThread myThread=new MyThread();
        System.out.println(myThread.write());
        myThread.read();
    }

}
```

#### 五、concurrentLinkedDeque

前置:

> 在Current包下,Queue跟Deque只要对队列元素进行操作一定是线程安全的

1、代码:

```java
public class MyThread {
    public static void main(String[] args) {
        ConcurrentLinkedDeque<Integer> concurrentLinkedDeque = new ConcurrentLinkedDeque<>();
        for (int i = 0; i < 10; i++) {
            //使用offer如果容器满了,会返回false,如果使用add()就直接报错。
            concurrentLinkedDeque.offer(i);
        }
        System.out.println(concurrentLinkedDeque);
        //poll()取出数据,并且会将此数据删除。(原子)
        System.out.println(concurrentLinkedDeque.pollFirst());
        System.out.println(concurrentLinkedDeque);
        //peek()取出数据,但是不会删除数据。(原子)
        System.out.println(concurrentLinkedDeque.peekFirst());
        System.out.println(concurrentLinkedDeque);
    }

}
```

#### 六、LinkedBlockingQueue

1.1、代码解释:

```java
public class MyThread {
    public static void main(String[] args) {
        LinkedBlockingQueue<String> linkedBlockingQueue = new LinkedBlockingQueue<>();
        new Thread(() -> {
            for (int x = 0; x < 10000; x++) {
                try {
                    //put()加了ReentrantLock锁,当执行添加操作之后,会释放锁。看面试总结,面试题2
                    linkedBlockingQueue.put(Thread.currentThread().getName() + ":" + x);
                    System.out.println("put:"+Thread.currentThread().getName() + ":" + x);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        new Thread(() -> {
            while (true) {
                try {
                    //take()加了ReentrantLock锁,Condition
                    //不断取出值直到队列里没有值
                    String take = linkedBlockingQueue.take();
                    System.out.println("take:"+take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

}
```

#### 七、ArrayBlockingQueue

1.1、代码解释:

```java
public class MyThread {
    //设置队列最大容量
    ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10, true);
    AtomicInteger atomicInteger=new AtomicInteger();
    public void change() {
        while (true){
            try {
                int x=atomicInteger.getAndIncrement();
                //原子添加元素,当添加到队列最大值时,会阻塞等待消费者
                blockingQueue.put(x);
                System.out.println("生产:"+x);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void domore() {
       while (true){
           try {
               //消费者不断从队列里取出
               Integer take = blockingQueue.take();
               System.out.println("消费"+take);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        //进行操作
        new Thread(() -> {
            myThread.change();
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -> {
            myThread.domore();
        }).start();
    }


}
```

#### 八、PriorityQueue

1.1、代码解释:

```java
public class MyThread {

    //创建priorityQueue
    private PriorityQueue<String> priorityQueue=new PriorityQueue<>();
    //让字母从大往小排
    char i='Z';
    public void change(){
        for (;i>='A';i--){
            //这里的offer线程不安全
            priorityQueue.offer(String.valueOf((char)i));
        }
    }
    public static void main(String[] args) {
        MyThread myThread=new MyThread();
        myThread.change();
        System.out.println(myThread.priorityQueue);
        while (true){
            String poll = myThread.priorityQueue.poll();
            if (poll==null) return;
            System.out.println(poll);
        }
    }

}
```



#### 九、SynchronousQueue

1.1、代码解释:

```java
public class MyThread {

    //这个具有特殊性,容器不能容纳元素,主要作用于两个线程相互交换数据
    //类似于new ArrayBlockingQueue<Integer>(1);
    SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();

    public void write(String value) {
        try {
            //往队列传入一个值,等待被接受,否则一直进入阻塞状态
            synchronousQueue.put(value);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    public void read() {
        while (true) {
            try {
                //当队列里有值,取出值
                String take = synchronousQueue.take();
                TimeUnit.SECONDS.sleep(1);
                System.out.println("取出值:" + take);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        //创建两个线程
        new Thread(() -> {
            while (true) {
                myThread.write(String.valueOf(new Random().nextInt(10) + 1));
            }
        }).start();

        new Thread(() -> {
            myThread.read();
        }).start();
    }

}
```

#### 十、TransferQueue

1.1、代码解释:

```java
public class MyThread {
    public static void main(String[] args) {
        TransferQueue<String> transferQueue=new LinkedTransferQueue();

        new Thread(()->{
            while (true){
                try {
                    transferQueue.transfer(String.valueOf(new Random().nextInt(10)+1));
                    System.out.println("推送了一条数据");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        new Thread(()->{
            while (true){
                try {
                    String take = transferQueue.take();
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println("接受了数据"+take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}
```

备注:

> 当transfer后线程进入阻塞状态,等待被接收,SynchronousQueue处理就是用的他。

##  七、线程池

#### 一、前置

1.1、线程池接口实现:

> Executor----ExecutorService-----ThreadPoolExecutor

#### 二、Callable

1.1、概念

> 在jdk1.5之后,新增了Callable,Callable类似于Runnable,但是Callable的call方法是带返回值的,而Runnable的run方法不带返回值。

2、代码解释:

```java
public class MyThread {
    public static void main(String[] args) {
        //不用线程池
        Callable<String> callable=new Callable<String>() {
            @Override
            public String call() throws Exception {
                System.out.println("call方法被执行了");
                //阻塞1秒
                TimeUnit.SECONDS.sleep(1);
                return "你好";
            }
        };
        
        //这里FutureTask实现了Runnable接口。
        FutureTask<String> future=new FutureTask<>(callable);
        //执行
        new Thread(future).start();
        try {
            //call方法return之前处于阻塞状态
            String s = future.get();
            System.out.println(s);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        
         //使用线程池
        //----------------------------------------------------------
        ExecutorService executors=Executors.newFixedThreadPool(5);
        //交给线程池去完成执行,主线程不受任何影响(异步)
        Future<Integer> submit = executors.submit(() -> {
            TimeUnit.SECONDS.sleep(5);
            return 1;
        });
        try {
            //一直阻塞直到call方法执行完成
            System.out.println(submit.get());
            //查看是否执行完成
            System.out.println(submit.isDone());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }finally {
            //关闭线程池
            executors.shutdown();
        }
    }
}
```

#### 三、CompletableFuture

1、前置

> CompletableFuture异步执行,将获取到的结果进行汇总。

```java
public class MyThread {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();
        //创建多个CompletableFuture去获取值(并行)
        CompletableFuture<Double> price1 = CompletableFuture.supplyAsync(() -> price1());
        CompletableFuture<Double> price2 = CompletableFuture.supplyAsync(() -> price2());
        CompletableFuture<Double> price3 = CompletableFuture.supplyAsync(() -> price3());
        //获取到值汇总
        CompletableFuture.allOf(price1, price2, price3).join(); //必须全部完成
//        CompletableFuture.anyOf(price1,price2,price3).join(); //只需一个完成
        CompletableFuture.supplyAsync(() -> {
            try {
                return price1.get();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
            return null;
        })
                .thenApply(String::valueOf)
                .thenApply(str -> "price:" + str)
                .thenAccept(System.out::println);

        Long end = System.currentTimeMillis();
        System.out.println(end - start);


    }

    public static double price1() {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return 12.3;
    }

    public static double price2() {
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return 34.2;
    }

    public static double price3() {
        try {
            TimeUnit.SECONDS.sleep(8);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return 98.32;
    }


}
```

#### 四、线程池

1、前置

> 概念:
>
> 1. 守护线程: 当主线程停止后(jvm停止),非守护线程不会受到影响,守护线程也会跟着主线程停止而停止。
> 2. 线程分组:更好的去管理线程。
> 3. 拒绝策略:当线程池接受到任务,线程首先让核心线程执行,如果核心线程都有任务(非空闲),此任务就会进入任务队列,线程池就会起一个新线程(小于等于线程池最大容纳线程个数)去执行任务队列任务，如果任务队列满了(任务队列满了说明线程池线程数满了,所有线程处于非空闲状态),就会执行拒绝策略。
> 4. 核心线程:当线程池所有线程处于空闲状态(没有任务),其他线程就会归还给系统,而核心线程不会。
> 4. 线程池里的线程都是守护线程。

```java
public class MyThread {
    public static void main(String[] args) {
        //对线程进行分组
        ThreadGroup threadGroup=new ThreadGroup("Group1");
        Thread thread=new Thread(threadGroup,()->{
            for (int i=0;i<1000;i++){
                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println(Thread.currentThread().getThreadGroup()+":"+i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        },"线程一");
        //设置为守护线程(当jvm停止后,守护线程也会停止)
        thread.setDaemon(true);
        //启动线程
        thread.start();
        try {
            //设置1秒后主线程退出(jvm退出)
            TimeUnit.SECONDS.sleep(1);
            System.out.println("jvm退出");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```

2、线程池参数与拒绝策略

```java
public class MyThread {
    public static void main(String[] args) throws InterruptedException {
        // 创建阻塞队列
        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue(10);
        //创建线程池
        ThreadPoolExecutor threadPoolExecutor =
                new ThreadPoolExecutor(5, 10,
                        60, TimeUnit.SECONDS, blockingQueue,
                        new MyThreadFactory(),
                        new ThreadPoolExecutor.AbortPolicy());
//         ThreadPoolExecutor  解释:
//         corePoolSize       核心线程数:
//         maximumPoolSize   最多可拓展线程数:
//         keepAliveTime    线程池在指定时间没有干活(除了核心线程),就归还给操作系统(消灭):
//         unit            存活时间的单位:
//         workQueue      指定任务执行个数:
//         threadFactory 产生线程的方式:
//         handler      线程池拒绝策略
//拒绝策略:        
//ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。       //ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。    //ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务    //CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务  溢出的任务交给调用的线程去执行
        
//清空任务队列,给线程池执行,不再接受任何任务。        


        //创建100个线程,当(线程容纳最大个数+任务队列容纳最大个数)>任务数,会启用拒绝策略。
        Runnable runnables[] = new Runnable[100];
        Demo demo = new Demo();
        for (int i = 0; i < runnables.length; i++) {
            runnables[i] = new Runnable() {
                @Override
                public void run() {
                    demo.change();
                }
            };
        }
        for (Runnable runnable : runnables) threadPoolExecutor.execute(runnable);
        threadPoolExecutor.shutdown();
    }

    final static class Demo {

        AtomicInteger atomicInteger = new AtomicInteger();
        public void change() {
            try {
                int i = atomicInteger.getAndIncrement();
                System.out.println(Thread.currentThread().getName()+":"+i);
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }


    //自定义线程产生方式
    final static class MyThreadFactory implements ThreadFactory {
        //初始化线程组编号
        private final AtomicInteger groupId = new AtomicInteger(0);
        //初始化线程池编号
        private final AtomicInteger poolId = new AtomicInteger(0);
        //初始化线程的名字
        private final AtomicInteger ThreadId = new AtomicInteger(0);
        //初始化线程组
        private ThreadGroup threadGroup;
        //初始化线程池名
        private String namePrefix;

        public MyThreadFactory() {
            //重置线程顺修名
            ThreadId.set(0);
            //创建线程组
            threadGroup = new ThreadGroup("Group:" + groupId.getAndIncrement());
            //创建线程池前缀
            namePrefix = "pool:" + poolId.getAndIncrement();
        }

        @Override
        public Thread newThread(Runnable r) {
            //创建线程名字
            String thread_name = namePrefix + "-" + "Thread:" + ThreadId.getAndIncrement();
            Thread thread = new Thread(threadGroup, r, thread_name);
            //查看是否是守护线程
            if (thread.isDaemon()) {
                //如果是守护线程,自动转换为非守护线程
                thread.setDaemon(false);
            }
            return thread;
        }
    }
}
```

3、自定义拒绝策略

```java

public class MyThread {
    //创建一把锁
    private static final ReentrantLock reentrantLock = new ReentrantLock();
    private static final Condition main_lock = reentrantLock.newCondition();
    private static final Condition checkCache_lock = reentrantLock.newCondition();

    public static void main(String[] args) throws InterruptedException {
        // 创建阻塞队列
        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue(10);
        //创建线程池
        ThreadPoolExecutor threadPoolExecutor =
                new ThreadPoolExecutor(5, 10,
                        60, TimeUnit.SECONDS, blockingQueue,
                        MyThreadFactoryAbstract.MyThreadFactoryT1.getInstance(),
                        new MyPolicy());

        //创建数据流量
        Runnable runnables[] = new Runnable[100];
        Demo demo = new Demo();
        for (int i = 0; i < runnables.length; i++) {
            runnables[i] = new Runnable() {
                @Override
                public void run() {
                    demo.change();
                }
            };
        }
        for (Runnable runnable : runnables) threadPoolExecutor.execute(runnable);
        //如果有剩余的任务
        if (undoneList.size() > 0) {
            try {
                reentrantLock.lock();
                checkCache();
                //等待缓存清除
                main_lock.await();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                reentrantLock.unlock();
            }
        }
        threadPoolExecutor.shutdown();
    }

    public static void checkCache() {
        new Thread(() -> {
            try {
                reentrantLock.lock();
                //创建超大的线程池
                // 创建阻塞队列
                BlockingQueue<Runnable> blockingQueue = new LinkedBlockingQueue<>();
                //创建线程池
                ThreadPoolExecutor threadPoolExecutor =
                        new ThreadPoolExecutor(100, 10000,
                                60, TimeUnit.SECONDS, blockingQueue,
                                MyThreadFactoryAbstract.MyThreadFactoryT1.getInstance(),
                                new MyPolicy());
                while (true) {
                    if (undoneList.size() == 0) break;
                    threadPoolExecutor.execute(undoneList.take());
                }
                //线程池执行结束
                threadPoolExecutor.shutdown();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                main_lock.signal();
                reentrantLock.unlock();
            }
        }).start();
    }

    final static class Demo {
        int i = 0;

        public void change() {
            synchronized (this) {
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                    i += 1;
                    System.out.println(Thread.currentThread().getName() + ":" + i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }


    //缓存未完成的任务
    static BlockingQueue<Runnable> undoneList = new LinkedBlockingQueue<>();

    //自定义拒绝策略
    static final class MyPolicy implements RejectedExecutionHandler {
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            try {
                //缓存未完成的任务
                undoneList.put(r);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    //自定义线程产生方式
    static abstract class MyThreadFactoryAbstract implements ThreadFactory {
        //初始化线程组编号
        protected final static AtomicInteger groupId = new AtomicInteger(0);
        //初始化线程池编号
        protected final static AtomicInteger poolId = new AtomicInteger(0);
        //初始化线程的名字
        protected final static AtomicInteger ThreadId = new AtomicInteger(0);
        //初始化线程组
        protected ThreadGroup threadGroup;
        //初始化线程池名
        protected String namePrefix;

        static class MyThreadFactoryT1 extends MyThreadFactoryAbstract {
            private MyThreadFactoryT1() {
                System.out.println(super.groupId);
                //重置线程顺修名
                super.ThreadId.set(0);
                //创建线程组
                super.threadGroup = new ThreadGroup("Group:" + super.groupId.getAndIncrement());
                //创建线程池前缀
                super.namePrefix = "pool:" + super.poolId.getAndIncrement();
            }

            public static MyThreadFactoryT1 getInstance() {
                return new MyThreadFactoryT1();
            }

            @Override
            public Thread newThread(Runnable r) {
                //创建线程名字
                String thread_name = super.namePrefix + "-" + "Thread:" + super.ThreadId.getAndIncrement();
                Thread thread = new Thread(super.threadGroup, r, thread_name);
                //查看是否是守护线程
                if (thread.isDaemon()) {
                    //如果是守护线程,自动转换为非守护线程
                    thread.setDaemon(false);
                }
                return thread;
            }
        }


    }
}
```

##### 1、SingleThreadExecutor

1.1、概念

> SingleThreadExecutor可以存储多个任务,但只有一个线程来完成所有的任务。能保证任务顺序执行。



```java
public class MyThread {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        //只有一个线程去执行所有的任务。任务队列长度为int的最大值。
        Runnable runnables[] = new Runnable[100];
        for (int i = 0; i < runnables.length; i++) {
            runnables[i] = new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName());
                }
            };
        }
        for (Runnable runnable : runnables) executorService.submit(runnable);
        executorService.shutdown();
    }
}
```

##### 2、CachedThreadPool

1.1、概念

> 一个线程对应一个任务。直接将任务交给线程池执行。

```java
public class MyThread {
    public static void main(String[] args) {
        //一个线程对应一个任务。直接将任务交给线程池执行。
        //如有任务堆积,就不要用
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                    while (true) {
                        System.out.println(Thread.currentThread().getName());
                    }
                }
                });
                executorService.submit(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            while (true) {
                                TimeUnit.SECONDS.sleep(1);
                                System.out.println(Thread.currentThread().getName());
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
                executorService.shutdown();

            }
        }
```

##### 3、FixedThreadPool

1.1、概念

> 指定线程核心个数跟最大线程个数,且任务队列容量为int的最大值

```java
public class MyThread {

    public static void main(String[] args) {
        //指定线程核心个数跟最大线程个数,且任务队列容量为int的最大值
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        Runnable runnables[]=new Runnable[100];
        for(int i=0;i<runnables.length;i++){
            runnables[i]=()->{
                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println(Thread.currentThread().getName());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            };
        }
        for (Runnable runnable:runnables) executorService.submit(runnable);
        executorService.shutdown();
    }
}
```

#### 五、并发,并行

1.1、前置

> 并发是指任务提交,并行指任务执行。

```java
public class MyThread {


    static class Task implements Runnable {

        int start;
        int end;

        public Task(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            for (int i = start; i < end; i++) {

            }
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //使用线程池与非使用线程池的区别
        //使用线程池
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        //创建四个任务
        Task task = new Task(0, 50000);
        Task task1 = new Task(50000, 100000);
        Task task2 = new Task(100000, 150000);
        Task task3 = new Task(150000, 200000);
        //并行执行
        Future<?> submit1 = executorService.submit(task);
        Future<?> submit2 = executorService.submit(task1);
        Future<?> submit3 = executorService.submit(task2);
        Future<?> submit4 = executorService.submit(task3);

        long start = System.currentTimeMillis();
        submit1.get();
        submit2.get();
        submit3.get();
        submit4.get();
        long end = System.currentTimeMillis();
        System.out.println("线程池执行时间为:"+(end-start));
        executorService.shutdown();

    }


}
```

#### 六、ForkJoinPool

1、前置

> 特点:每一个线程维护者一个任务队列,而一个任务可以拆分为多个子任务。

1.1、RecursiveAction

> 他是不带返回值的,不断去分割任务,直到满足条件为止。

```java
public class MyThread {
    //创建一个容量为100万的数组
    private static int sum[] = new int[1000000];

    static {
        for (int i = 0; i < sum.length; i++) {
            //往数组里放值
            sum[i] = i + 1;
        }
    }

    //上锁
    final static Object lock = new Object();
    //计算结果
    static int x = 0;
    //创建门栓
    private static CountDownLatch countDownLatch=new CountDownLatch(sum.length);

    static class Demo extends RecursiveAction {
        private int start;
        private int end;
        //创建最大任务执行量
        private int MAX_NUM = 500000;

        public Demo(int start, int end) {
            this.start = start;
            this.end = end;
        }
        @Override
        protected void compute() {
            //如果任务数量执行量小于规定任务执行量,不做分片处理。否则进行分片。
            if ((end - start) <= MAX_NUM) {
                int sum1=0;
                for (int i = start; i < end; i++) {
                   sum1+=i;
                   countDownLatch.countDown();
                }
                synchronized (lock){
                    x+=sum1;
                }
            } else {
                //取中间值
                int middle = start + (end - start) / 2;
                Demo left = new Demo(start, middle);
                Demo right = new Demo(middle, end);
                //开辟多个子任务,且从线程池取多个线程去执行。
                left.fork();
                right.fork();
            }

        }
    }

    public static void main(String[] args) throws ClassNotFoundException, IOException, InterruptedException {
        //初始化nums
        Class<MyThread> myThreadClass = MyThread.class;
        //创建forkJoinPool线程池
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Demo demo = new Demo(0, sum.length);
        //执行任务
        forkJoinPool.execute(demo);
        countDownLatch.await();
        System.out.println(x);



    }


}
```

1.2、RecursiveTask

> 带返回值的,不断去分割任务,直到满足条件为止。

```java
public class MyThread {
    //创建一个容量为100万的数组
    private static int sum[] = new int[1000000];

    static {
        for (int i = 0; i < sum.length; i++) {
            //往数组里放值
            sum[i] = i + 1;
        }
    }

    //创建门栓
    private static CountDownLatch countDownLatch=new CountDownLatch(sum.length);

    static class Demo extends RecursiveTask<Integer> {
        private int start;
        private int end;
        //创建最大任务执行量
        private int MAX_NUM = 500000;

        public Demo(int start, int end) {
            this.start = start;
            this.end = end;
        }
        @Override
        protected Integer compute() {
            //如果任务数量执行量小于规定任务执行量,不做分片处理。否则进行分片。
            if ((end - start) <= MAX_NUM) {
                int sum1=0;
                for (int i = start; i < end; i++) {
                   sum1+=i;
                   countDownLatch.countDown();
                }
                return sum1;
            } else {
                //取中间值
                int middle = start + (end - start) / 2;
                Demo left = new Demo(start, middle);
                Demo right = new Demo(middle, end);
                //开辟多个子任务,且从线程池取多个线程去执行。
                left.fork();
                right.fork();
                return left.join() + right.join();
            }

        }
    }

    public static void main(String[] args) throws ClassNotFoundException, IOException, InterruptedException {
        //初始化nums
        Class<MyThread> myThreadClass = MyThread.class;
        //创建forkJoinPool线程池
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Demo demo = new Demo(0, sum.length);
        //执行任务
        forkJoinPool.execute(demo);
        countDownLatch.await();
        //执行结束获取值
        System.out.println(demo.join());
    }


}
```

#### 八、JMH测试工具

1、导入此xml文件

```xml
<dependencies>
    <!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core -->
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-core</artifactId>
        <version>1.33</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess -->
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-generator-annprocess</artifactId>
        <version>1.33</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

1.1、测试的时候在此路径打开注解解析,允许JMH对注解进行处理。

> setting--->Build,Excution,Deployment--->Compiler--->Annotation Processors--->打开 Enable Annotation Processors

1.2、测试用例:

```java
public class CT {

    //测试注解
    @Benchmark
    //预热: iterations:首先执行一次,time:等待三秒钟,timeUnit:时间单位
    //jvm会将执行的代码编译为本地代码(JIT),相当于执行二进制文件,效率非常高
    @Warmup(iterations = 1,time = 3)
    //起多少个线程去执行
    @Fork(4)
    //执行模式,这里设置吞吐量,指的是每秒执行多少次
    @BenchmarkMode(Mode.Throughput)
    //整个方法要测试多少遍
    @Measurement(iterations = 1,time = 3)
    //需要执行的方法
    public void change(){
        MyThread myThread = new MyThread();
        myThread.change2();
    }
}
```
